{"version":3,"sources":["components/Node/Node.jsx","utils/animation.js","algorithms/dijkstra.js","algorithms/stack.js","algorithms/DFS.js","algorithms/queue.js","algorithms/BFS.js","algorithms/A-star.js","utils/constants.js","factory/GridFactory.jsx","components/Grid.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseLeave","extraClassName","id","className","Animation","visitedNodesInOrder","nodesInShortestPathOrder","i","length","setTimeout","animateShortestPath","node","document","getElementById","visualizeDijkstra","grid","startNode","finishNode","startNodeVisualization","finishNodeVisualization","distance","unvisitedNodes","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","isVisited","push","updateUnvisitedNeighbors","dijkstra","currentNode","unshift","previousNode","getNodesInShortestPathOrder","animateAlgorithm","nodes","sort","nodeA","nodeB","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","neighbors","filter","Stack","this","items","element","pop","visualizeDFS","stack","size","top","adjacent","DFS","newnodes","Queue","visualizeBFS","queue","BFS","visualizeAstar","AStar","distanceToFinishNode","Constants","ROWS_NUMBER","COLUMNS_NUMBER","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","GridFactory","getInitialGrid","currentRow","createNode","clearGrid","getNewGridWithWallToggled","newGrid","slice","newNode","getNewGridWithStarNode","leaveTheNode","getNewGridWithFinishNode","Math","abs","Grid","useState","isMoving","setStartNode","setFinishNode","isMousePressed","setIsMousePressed","setGrid","randomNumber","mx","mn","floor","random","onClick","initial","end","j","generateRandomMaze","onMouseUp","map","rowIdx","nodeIdx","mouseIsPressed","nodeClicked","handleMouseDown","handleMouseEnter","handleMouseLeave","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.ea1d2ed4.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\nimport './Node.css';\n\nconst Node = ({row, col, isFinish, isStart, isWall, onMouseDown, onMouseEnter, onMouseLeave}) => {\n  const extraClassName = isFinish\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : \"\";\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseLeave={() => onMouseLeave(row, col)}\n    ></div>\n  );\n};\n\nexport default Node;","export default class Animation{\n\n    static animateAlgorithm  (visitedNodesInOrder, nodesInShortestPathOrder) {\n       for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n         if (i === visitedNodesInOrder.length) {\n           setTimeout(() => {\n             this.animateShortestPath(nodesInShortestPathOrder);\n           }, 10 * i);\n           return;\n         }\n         setTimeout(() => {\n           const node = visitedNodesInOrder[i];\n           document.getElementById(`node-${node.row}-${node.col}`).className =\n             'node node-visited';\n         }, 10 * i);\n       }\n     }\n   \n     static animateShortestPath (nodesInShortestPathOrder) {\n       for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n         setTimeout(() => {\n           const node = nodesInShortestPathOrder[i];\n           document.getElementById(`node-${node.row}-${node.col}`).className =\n             'node node-shortest-path';\n         }, 50 * i);\n       }\n     }\n    }","//In Dijkstra Algorithm we start with our node and relax all the node connected by it only \n// if d[u]+w<d[v] (w->v path) and greedle chooses next min distance node available to user\n// and follow the same recursivly thus this is a greedy approach. \n\n//in shortest path we will keep track of the previous node of all the nodes in shortest path \n//so as to back track it\nimport Animation from \"../utils/animation.js\";\nexport function visualizeDijkstra(grid, startNode, finishNode) {\n  const startNodeVisualization = grid[startNode.row][startNode.col];\n  const finishNodeVisualization = grid[finishNode.row][finishNode.col];\n  const visitedNodesInOrder = dijkstra(\n    grid,\n    startNodeVisualization,\n    finishNodeVisualization\n  );\n\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(\n    finishNodeVisualization\n  );\n\n  Animation.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n}\n\n\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    //priority queue can be used for optimizatin since we are sorting all node by distance and picking up the least,\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();//removes the 1st element\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    //push that least node in our animated path\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  } return visitedNodesInOrder;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\nconst getAllNodes = (grid) => {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nconst sortNodesByDistance = (unvisitedNodes) => {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n};\n\nconst updateUnvisitedNeighbors = (node, grid) => {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n};\n\nconst getUnvisitedNeighbors = (node, grid) => {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n};","\nclass Stack {\n    constructor() {\n        this.items = [];\n    }\n\n    push(element) {\n        this.items.push(element);\n    }\n\n    pop() {\n        return this.items.pop();\n    }\n\n    peek() {\n        return this.items[this.items.length - 1];\n    }\n\n    isEmpty() {\n        return this.items.length === 0;\n    }\n\n    size() {\n        return this.items.length;\n    }\n\n    clear() {\n        this.items = [];\n    }\n\n}\nexport default Stack;","\nimport Animation from \"../utils/animation.js\";\nimport Stack from \"../algorithms/stack.js\";\nexport function visualizeDFS(grid, startNode, finishNode) {\n  const startNodeVisualization = grid[startNode.row][startNode.col];\n  const finishNodeVisualization = grid[finishNode.row][finishNode.col];\n  const visitedNodesInOrder = DFS(\n    grid,\n    startNodeVisualization,\n    finishNodeVisualization\n  );\n\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(\n    finishNodeVisualization\n  );\n\n  Animation.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\nexport function DFS(grid, startNode, finishNode) {\n   const stack=new Stack();\n   const visitedNodesInOrder = [];\n   stack.push(startNode);\n   while(!!stack.size())\n   {\n     const top=stack.pop();\n     if(top==finishNode) return visitedNodesInOrder;\n     if (!top.isWall && (top.isStart || !top.isVisited) ) {\n      top.isVisited = true;\n      visitedNodesInOrder.push(top);\n     const adjacent=updateUnvisitedNeighbors(top,grid);\n     for (const node of adjacent)\n     {\n      stack.push(node);\n     }\n    }\n  }\n\n   \n   return visitedNodesInOrder;\n}\n\nconst updateUnvisitedNeighbors = (node, grid) => {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  const newnodes = []\n  for (const neighbor of unvisitedNeighbors) {\n       neighbor.previousNode = node;\n       newnodes.push(neighbor)\n  }\n  return newnodes;\n};\n\nconst getUnvisitedNeighbors = (node, grid) => {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n};","\nclass Queue {\n    constructor() {\n        this.items = [];\n    }\n\n    push(element) {\n        this.items.push(element);\n    }\n\n    pop() {\n        return this.items.shift();\n    }\n\n    peek() {\n        return this.items[this.items.length - 1];\n    }\n\n    isEmpty() {\n        return this.items.length === 0;\n    }\n\n    size() {\n        return this.items.length;\n    }\n\n    clear() {\n        this.items = [];\n    }\n\n}\nexport default Queue;","\nimport Animation from \"../utils/animation.js\";\nimport Queue from \"../algorithms/queue.js\";\nexport function visualizeBFS(grid, startNode, finishNode) {\n  const startNodeVisualization = grid[startNode.row][startNode.col];\n  const finishNodeVisualization = grid[finishNode.row][finishNode.col];\n  const visitedNodesInOrder = BFS(\n    grid,\n    startNodeVisualization,\n    finishNodeVisualization\n  );\n\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(\n    finishNodeVisualization\n  );\n\n  Animation.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n}\n\n function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\n function BFS(grid, startNode, finishNode) {\n   const queue=new Queue();\n   const visitedNodesInOrder = [];\n   queue.push(startNode);\n   while(!!queue.size())\n   {\n     const top=queue.pop();\n     if(top==finishNode) return visitedNodesInOrder;\n     if (!top.isWall && (top.isStart || !top.isVisited) ) {\n      top.isVisited = true;\n      visitedNodesInOrder.push(top);\n     const adjacent=updateUnvisitedNeighbors(top,grid);\n     for (const node of adjacent)\n     {\n      queue.push(node);\n     }\n    }\n  }\n\n   \n   return visitedNodesInOrder;\n}\n\nconst updateUnvisitedNeighbors = (node, grid) => {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  const newnodes = []\n  for (const neighbor of unvisitedNeighbors) {\n       neighbor.previousNode = node;\n       newnodes.push(neighbor)\n  }\n  return newnodes;\n};\n\nconst getUnvisitedNeighbors = (node, grid) => {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n};","\nimport Animation from \"../utils/animation.js\";\nexport function visualizeAstar(grid, startNode, finishNode) {\n    const startNodeVisualization = grid[startNode.row][startNode.col];\n    const finishNodeVisualization = grid[finishNode.row][finishNode.col];\n    const visitedNodesInOrder = AStar(\n      grid,\n      startNodeVisualization,\n      finishNodeVisualization\n    );\n  \n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(\n      finishNodeVisualization\n    );\n  \n    Animation.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n\nexport function AStar(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    //priority queue can be used for optimizatin since we are sorting all node by distance and picking up the least,\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();//removes the 1st element\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    //push that least node in our animated path\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  } return visitedNodesInOrder;\n  }\n\n  export function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n  \n  \n  const getAllNodes = (grid) => {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  };\n  \n  const sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  };\n  \n\n  const updateUnvisitedNeighbors = (node, grid) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\n      neighbor.previousNode = node;\n    }\n  };\n  const getUnvisitedNeighbors = (node, grid) => {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter((neighbor) => !neighbor.isVisited);\n  };","export default class Constants {\n    static ROWS_NUMBER = 28;\n    static COLUMNS_NUMBER = 72;\n  \n    static START_NODE_ROW = 10;\n    static START_NODE_COL = 15;\n    static FINISH_NODE_ROW = 11;\n    static FINISH_NODE_COL = 35;\n  }","import Constants from \"../utils/constants\";\nimport React, { Fragment, useState } from \"react\";\nexport default class GridFactory {\n  \n\n\n  static getInitialGrid = (startNode, finishNode) => {\n    const grid = [];\n    for (let row = 0; row < Constants.ROWS_NUMBER; row++) {\n      const currentRow = [];\n      for (let col = 0; col < Constants.COLUMNS_NUMBER; col++) {\n        currentRow.push(this.createNode(col, row, startNode, finishNode));\n      }\n      grid.push(currentRow);\n    }\n    //grid=clearGrid(grid,startNode,finishNode);\n    return grid;\n  };\n\n  static clearGrid = (startNode, finishNode) => {\n    \n    const grid = [];\n    \n    for (let row = 0; row < Constants.ROWS_NUMBER; row++) {\n      const currentRow = [];\n      for (let col = 0; col < Constants.COLUMNS_NUMBER; col++) {\n        currentRow.push(this.createNode(col, row, startNode, finishNode));\n        if (col === startNode.col && row === startNode.row) {\n          document.getElementById(`node-${row}-${col}`).className =\n            \"node node-start\";\n        } else if (col === finishNode.col && row === finishNode.row) {\n          document.getElementById(`node-${row}-${col}`).className =\n            \"node node-finish\";\n        } else {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n\n  \n\n\n\n  static getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n      \n    const newNode = {\n      ...node,\n      isWall: 1,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  static getNewGridWithStarNode = (grid, row, col, leaveTheNode) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isStart: !leaveTheNode,\n      isWall: false,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  static getNewGridWithFinishNode = (grid, row, col, leaveTheNode) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isFinish: !leaveTheNode,\n      isWall: false,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  static createNode = (col, row, startNode, finishNode) => {\n    return {\n      col,\n      row,\n      isStart: row === startNode.row && col === startNode.col,\n      isFinish: row === finishNode.row && col === finishNode.col,\n      distance: Infinity,  //manhattanDistance of final and current node\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      distanceToFinishNode:Math.abs(finishNode.row - row)+ Math.abs(finishNode.col - col),\n    };\n  };\n}","import React, { Fragment, useState } from \"react\";\nimport Node from \"./Node/Node\";\n\n\nimport { visualizeDijkstra } from \"../algorithms/dijkstra\";\nimport { visualizeDFS } from \"../algorithms/DFS\";\nimport { visualizeBFS } from \"../algorithms/BFS\";\nimport { visualizeAstar } from \"../algorithms/A-star\";\nimport Navbar from \"./Layout/Navbar\";\nimport GridFactory from \"../factory/GridFactory\";\nimport Constants from \"../utils/constants\";\n\nimport \"./Grid.css\";\n\nconst Grid = () => {\n  const [startNode, setStartNode] = useState({\n    row: Constants.START_NODE_ROW,\n    col: Constants.START_NODE_COL,\n    isMoving: false,\n  });\n  const [finishNode, setFinishNode] = useState({\n    row: Constants.FINISH_NODE_ROW,\n    col: Constants.FINISH_NODE_COL,\n    isMoving: false,\n  });\n\n  const [isMousePressed, setIsMousePressed] = useState(false);\n\n  const [grid, setGrid] = useState(\n    GridFactory.getInitialGrid(startNode, finishNode)\n  );\n\n  const randomNumber = (mx, mn) =>\n  {\n    return Math.floor(Math.random() * (mx - mn +1) ) + mn;\n  }\n\n   const generateRandomMaze =(startNode, finishNode) => {\n     \n    for(var i=1;i<Constants.ROWS_NUMBER;i++)\n  {\n      if(i%2==0)\n      {\n          const initial=randomNumber(Constants.COLUMNS_NUMBER-1,1);\n          const end=randomNumber(Constants.COLUMNS_NUMBER-1,initial);\n          for(var j=initial;j<=end;j++)\n          { if(i===startNode.row && j==startNode.col) continue;\n            if(i===finishNode.row && j==finishNode.col) continue;\n            const newGrid = GridFactory.getNewGridWithWallToggled(grid, i, j);\n            setGrid(newGrid);\n                    }\n      }\n\n      \n  }\n\n  for(var i=1;i<Constants.COLUMNS_NUMBER;i++)\n  {\n      if(i%2==0)\n      {\n        const initial=randomNumber(Constants.ROWS_NUMBER-1,1);\n        const end=randomNumber(Constants.ROWS_NUMBER-1,initial);\n        for(var j=initial;j<=end;j++)\n        { if(j===startNode.row && i==startNode.col) continue;\n          if(j===finishNode.row && i==finishNode.col) continue;\n          const newGrid = GridFactory.getNewGridWithWallToggled(grid, j, i);\n          setGrid(newGrid);\n         \n        }\n\n      }\n  }\n\n  };\n\n\n  \n  const handleMouseDown = (row, col) => {\n    setIsMousePressed(true);\n    let nodeClicked = grid[row][col];\n    if (nodeClicked.isStart) {\n      setStartNode({ ...startNode, isMoving: true });\n    } else if (nodeClicked.isFinish) {\n      setFinishNode({ ...finishNode, isMoving: true });\n    } else {\n      const newGrid = GridFactory.getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!isMousePressed) return;\n    if (startNode.isMoving) {\n      setGrid(GridFactory.getNewGridWithStarNode(grid, row, col, false));\n      setStartNode({ ...startNode, row, col });\n    } else if (finishNode.isMoving) {\n      setGrid(GridFactory.getNewGridWithFinishNode(grid, row, col, false));\n      setFinishNode({ ...finishNode, row, col });\n    } else {\n      setGrid(GridFactory.getNewGridWithWallToggled(grid, row, col));\n    }\n  };\n\n  const handleMouseLeave = (row, col) => {\n    if (!isMousePressed) return;\n    let newGrid;\n    if (startNode.isMoving) {\n      newGrid = GridFactory.getNewGridWithStarNode(grid, row, col, true);\n      setGrid(newGrid);\n    } else if (finishNode.isMoving) {\n      newGrid = GridFactory.getNewGridWithFinishNode(\n        grid,\n        row,\n        col,\n        true\n      );\n      setGrid(newGrid);\n    }\n  };\n\n  const handleMouseUp = () => {\n    setIsMousePressed(false);\n    setStartNode({ ...startNode, isMoving: false });\n    setFinishNode({ ...finishNode, isMoving: false });\n  };\n\n  return (\n    <Fragment>\n        <button className=\"top-buttons\" onClick={() => visualizeDijkstra(grid, startNode, finishNode)}>\n          Visualize Dijkstra's Algorithm\n        </button>\n        <button className=\"top-buttons\" onClick={() => visualizeBFS(grid, startNode, finishNode)}>\n          Visualize BFS Algorithm\n        </button>\n        <button className=\"top-buttons\" onClick={() => visualizeDFS(grid, startNode, finishNode)}>\n          Visualize DFS Algorithm\n        </button>\n        <button className=\"top-buttons\" onClick={() => visualizeAstar(grid, startNode, finishNode)}>\n          Visualize A* Algorithm\n        </button>\n        <button className=\"top-buttons\" onClick={() => generateRandomMaze(startNode, finishNode)}>\n          Generate Random walls \n        </button>\n        \n        <button className=\"top-buttons\" onClick={() =>(setGrid(GridFactory.clearGrid(startNode, finishNode)))}>\n          Clear Grid \n        </button>\n        \n       \n        <div className=\"grid\" onMouseUp={() => handleMouseUp()}>\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node;\n                  return (\n                  <Node\n                    key={nodeIdx}\n                    col={col}\n                    isFinish={isFinish}\n                    isStart={isStart}\n                    isWall={isWall}\n                    mouseIsPressed={isMousePressed}\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                    onMouseLeave={(row, col) => handleMouseLeave(row, col)}\n                    row={row}\n                  ></Node>\n                );\n                })}\n              </div>\n            );\n          })}\n        </div>\n    </Fragment>\n  );\n};\n\nexport default Grid;","import React from 'react';\nimport './App.css';\nimport Grid from './components/Grid.jsx'\n\nfunction App() {\n    return ( < div className = \"App\" >\n     <Grid/> \n      </div> );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}